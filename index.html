<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æµ·æ´‹æ¶ˆæ¶ˆä¹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
            -webkit-tap-highlight-color: transparent; /* å–æ¶ˆæ‰‹æœºç‚¹å‡»é«˜äº® */
        }
        body {
            background: #f0f8fb;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            touch-action: none; /* ç¦ç”¨é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆå…³é”®ä¼˜åŒ–ï¼‰ */
        }
        .game-header {
            width: 100%;
            max-width: 450px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .game-title {
            color: #2d5b79;
            font-size: 20px;
        }
        .play-count {
            color: #d9534f;
            font-size: 14px;
            background: #fff;
            padding: 4px 8px;
            border-radius: 16px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .game-info {
            margin-bottom: 10px;
            text-align: center;
            display: flex;
            gap: 30px;
        }
        .info-item {
            font-size: 16px;
            color: #333;
        }
        .info-item span {
            font-weight: bold;
            color: #2d5b79;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* è‡ªé€‚åº”å®½åº¦ï¼ˆå…³é”®ä¼˜åŒ–ï¼‰ */
            gap: 8px;
            background: #e8f4f8;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 450px;
        }
        .grid-cell {
            aspect-ratio: 1/1; /* æ­£æ–¹å½¢æ ¼å­ï¼ˆå…³é”®ä¼˜åŒ–ï¼‰ */
            background: #fff;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            position: relative;
        }
        .grid-cell.selected {
            background: #ffe485;
            box-shadow: 0 0 0 2px #ffc107;
        }
        .grid-cell.empty {
            background: #f5f5f5;
            opacity: 0.5;
        }
        /* åŠ é€ŸåŠ¨ç”»ï¼ˆå…³é”®ä¼˜åŒ–ï¼šç¼©çŸ­åŠ¨ç”»æ—¶é•¿ï¼‰ */
        @keyframes fall {
            from { transform: translateY(-80px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .grid-cell.fall {
            animation: fall 0.15s ease-out forwards; /* åŸ0.3s â†’ 0.15s */
        }
        @keyframes pop {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        .grid-cell.pop {
            animation: pop 0.15s ease-out forwards; /* åŸ0.3s â†’ 0.15s */
        }
        .tips {
            margin-top: 15px;
            color: #666;
            font-size: 14px;
            line-height: 1.4;
            text-align: center;
            max-width: 450px;
        }
        .btn-restart {
            margin-top: 12px;
            padding: 7px 18px;
            background: #2d5b79;
            color: #fff;
            border: none;
            border-radius: 16px;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-restart:hover {
            background: #1a3b53;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h2 class="game-title">é¾™å®«æ¸¸å›­ä¼šÂ·æµ·æ´‹æ¶ˆæ¶ˆä¹</h2>
        <div class="play-count">ä»Šæ—¥å‰©ä½™æ­£å¼å±€ï¼š<span id="official-count">2</span></div>
    </div>

    <div class="game-info">
        <div class="info-item">å¾—åˆ†ï¼š<span id="score">0</span></div>
        <div class="info-item">å‰©ä½™ï¼š<span id="remain-connect">10</span></div>
    </div>

    <div class="grid-container" id="gridContainer"></div>

    <button class="btn-restart" id="restartBtn">é‡æ–°å¼€å§‹</button>

    <div class="tips">
        ğŸ”¹ æŒ‰ä½æ‹–åŠ¨è¿3ä¸ªä»¥ä¸Šç›¸åŒç”Ÿç‰©ï¼ˆå¯æ–œè¿ï¼‰<br>
        ğŸ”¹ 10æ¬¡è¿çº¿åç»“ç®—ï¼Œ90åˆ†è·ã€Œç‰¹ã€çº§ç§¯åˆ†
    </div>

    <script>
        // 1. æ¸¸æˆé…ç½®ï¼ˆæé€Ÿä¼˜åŒ–ï¼‰
        const config = {
            gridSize: 5,
            types: ['ğŸŸ', 'ğŸ¦', 'ğŸš', 'ğŸ¦€','ğŸ ','ğŸ¦‘'],
            maxConnect: 10,
            dailyOfficialCount: 2,
            scoreRules: { 3: 5, 4: 12, 5: 25, '6+': 40 },
            rankRules: [
                { min: 90, rank: 'ç‰¹', reward: 20 },
                { min: 60, rank: 'ä¼˜', reward: 15 },
                { min: 30, rank: 'è‰¯', reward: 10 },
                { min: 0, rank: 'å·®', reward: 0 }
            ]
        };

        // 2. å…¨å±€çŠ¶æ€
        let gameGrid = [];
        let currentScore = 0;
        let connectCount = 0;
        let startPos = null;
        let path = [];
        let isDragging = false;
        let remainingOfficialCount = config.dailyOfficialCount;
        let isOfficialGame = false;
        let gridCells = []; // ç¼“å­˜æ ¼å­DOMï¼ˆé¿å…é¢‘ç¹æŸ¥è¯¢ï¼Œå…³é”®ä¼˜åŒ–ï¼‰

        // 3. DOMå…ƒç´ 
        const gridContainer = document.getElementById('gridContainer');
        const scoreEl = document.getElementById('score');
        const remainConnectEl = document.getElementById('remain-connect');
        const officialCountEl = document.getElementById('official-count');
        const restartBtn = document.getElementById('restartBtn');

        // 4. åˆå§‹åŒ–æ¸¸æˆï¼ˆç®€åŒ–æµç¨‹ï¼‰
        function initGrid(isOfficial = false) {
            isOfficialGame = isOfficial;
            // ç”Ÿæˆæ£‹ç›˜ï¼ˆç®€åŒ–æ•°ç»„åˆ›å»ºï¼Œå…³é”®ä¼˜åŒ–ï¼‰
            gameGrid = [];
            for (let i = 0; i < config.gridSize; i++) {
                const row = [];
                for (let j = 0; j < config.gridSize; j++) {
                    row.push(config.types[Math.floor(Math.random() * config.types.length)]);
                }
                gameGrid.push(row);
            }
            currentScore = 0;
            connectCount = 0;
            path = [];
            startPos = null;
            updateInfo();
            renderGrid();
            ensurePlayableGrid();

            // æ­£å¼å±€å¤„ç†ï¼ˆç®€åŒ–é€»è¾‘ï¼‰
            if (isOfficial && remainingOfficialCount > 0) {
                remainingOfficialCount--;
                officialCountEl.textContent = remainingOfficialCount;
                localStorage.setItem('oceanMatchOfficialCount', remainingOfficialCount);
            }
        }

        // 5. æ¸²æŸ“æ£‹ç›˜ï¼ˆç¼“å­˜DOM+å‡å°‘æ“ä½œï¼Œå…³é”®ä¼˜åŒ–ï¼‰
        function renderGrid(animateCells = []) {
            gridContainer.innerHTML = '';
            gridCells = []; // é‡ç½®ç¼“å­˜
            const animateMap = new Map(); // ç”¨Mapå¿«é€ŸæŸ¥è¯¢åŠ¨ç”»ï¼ˆå…³é”®ä¼˜åŒ–ï¼‰
            animateCells.forEach(cell => animateMap.set(`${cell.row}-${cell.col}`, cell.type));

            for (let rowIdx = 0; rowIdx < config.gridSize; rowIdx++) {
                for (let colIdx = 0; colIdx < config.gridSize; colIdx++) {
                    const cell = gameGrid[rowIdx][colIdx];
                    const cellEl = document.createElement('div');
                    cellEl.className = 'grid-cell';
                    cellEl.dataset.row = rowIdx; // å­˜å‚¨åæ ‡ï¼ˆé¿å…é‡æ–°è®¡ç®—ï¼‰
                    cellEl.dataset.col = colIdx;
                    
                    if (!cell) cellEl.classList.add('empty');
                    // é€‰ä¸­çŠ¶æ€ï¼ˆç®€åŒ–åˆ¤æ–­ï¼Œå…³é”®ä¼˜åŒ–ï¼‰
                    if (path.some(p => p.row === rowIdx && p.col === colIdx)) {
                        cellEl.classList.add('selected');
                    }
                    cellEl.textContent = cell || '';

                    // å¿«é€Ÿæ·»åŠ åŠ¨ç”»ï¼ˆå…³é”®ä¼˜åŒ–ï¼‰
                    const animateType = animateMap.get(`${rowIdx}-${colIdx}`);
                    if (animateType) cellEl.classList.add(animateType);

                    // è§¦æ‘¸äº‹ä»¶ï¼ˆç®€åŒ–ç»‘å®šï¼Œå…³é”®ä¼˜åŒ–ï¼‰
                    cellEl.addEventListener('touchstart', handleTouchStart);
                    cellEl.addEventListener('touchmove', handleTouchMove);

                    gridContainer.appendChild(cellEl);
                    gridCells.push(cellEl); // ç¼“å­˜DOM
                }
            }

            // å…¨å±€è§¦æ‘¸ç»“æŸï¼ˆåªç»‘å®š1æ¬¡ï¼Œå…³é”®ä¼˜åŒ–ï¼‰
            document.ontouchend = handleTouchEnd;
            document.onmouseup = handleMouseUp;
        }

        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯è¿æˆ3ä¸ªåŠä»¥ä¸Šçš„ç»„åˆï¼ˆå«æ–œå‘ï¼‰
        function hasConnectable() {
            const visited = Array.from({ length: config.gridSize }, () => Array(config.gridSize).fill(false));
            const dirs = [
                [1, 0], [-1, 0], [0, 1], [0, -1],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];
            for (let r = 0; r < config.gridSize; r++) {
                for (let c = 0; c < config.gridSize; c++) {
                    if (!gameGrid[r][c] || visited[r][c]) continue;
                    const target = gameGrid[r][c];
                    const queue = [[r, c]];
                    visited[r][c] = true;
                    let count = 0;
                    while (queue.length) {
                        const [cr, cc] = queue.pop();
                        count++;
                        for (const [dr, dc] of dirs) {
                            const nr = cr + dr, nc = cc + dc;
                            if (nr < 0 || nr >= config.gridSize || nc < 0 || nc >= config.gridSize) continue;
                            if (visited[nr][nc]) continue;
                            if (gameGrid[nr][nc] === target) {
                                visited[nr][nc] = true;
                                queue.push([nr, nc]);
                            }
                        }
                    }
                    if (count >= 3) return true;
                }
            }
            return false;
        }

        // å½“æ— å¯æ¶ˆé™¤ç»„åˆæ—¶ï¼Œè‡ªåŠ¨é‡æ’æ£‹ç›˜ï¼ˆä¿ç•™å½“å‰å¾—åˆ†å’Œæ¬¡æ•°ï¼‰
        function ensurePlayableGrid() {
            if (hasConnectable()) return;
            let attempts = 0;
            while (attempts < 30) {
                for (let r = 0; r < config.gridSize; r++) {
                    for (let c = 0; c < config.gridSize; c++) {
                        gameGrid[r][c] = config.types[Math.floor(Math.random() * config.types.length)];
                    }
                }
                if (hasConnectable()) break;
                attempts++;
            }
            renderGrid();
        }

        // 6. è§¦æ‘¸äº‹ä»¶ä¼˜åŒ–ï¼ˆåˆå¹¶é€»è¾‘+å‡å°‘è®¡ç®—ï¼‰
        function handleTouchStart(e) {
            e.preventDefault();
            const row = parseInt(this.dataset.row);
            const col = parseInt(this.dataset.col);
            if (gameGrid[row][col]) {
                startPos = { row, col };
                path = [{ row, col }];
                updateSelectedCells(); // å•ç‹¬æ›´æ–°é€‰ä¸­çŠ¶æ€ï¼ˆé¿å…å…¨é‡æ¸²æŸ“ï¼‰
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!startPos) return;
            const touch = e.touches[0];
            // å¿«é€Ÿè·å–ç›®æ ‡æ ¼å­ï¼ˆå‡å°‘DOMæŸ¥è¯¢ï¼Œå…³é”®ä¼˜åŒ–ï¼‰
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!target || !target.classList.contains('grid-cell')) return;

            const row = parseInt(target.dataset.row);
            const col = parseInt(target.dataset.col);
            if (!gameGrid[row][col]) return;

            const lastPos = path[path.length - 1];
            // ç®€åŒ–è§„åˆ™åˆ¤æ–­ï¼ˆå…³é”®ä¼˜åŒ–ï¼‰
            const isAdjacent = Math.abs(row - lastPos.row) <= 1 && Math.abs(col - lastPos.col) <= 1;
            const isDuplicate = path.some(p => p.row === row && p.col === col);
            const isSameType = gameGrid[row][col] === gameGrid[startPos.row][startPos.col];

            if (isAdjacent && !isDuplicate && isSameType) {
                path.push({ row, col });
                updateSelectedCells(); // å•ç‹¬æ›´æ–°é€‰ä¸­çŠ¶æ€
            }
        }

        function handleTouchEnd() {
            if (path.length >= 3) {
                handleConnect(); // ç›´æ¥å¤„ç†è¿çº¿ç»“ç®—ï¼ˆå‡å°‘å»¶è¿Ÿï¼‰
            } else {
                path = [];
                updateSelectedCells();
            }
            startPos = null;
        }

        // 7. é¼ æ ‡äº‹ä»¶ï¼ˆç®€åŒ–é€‚é…ï¼‰
        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                handleTouchEnd();
            }
        }

        // 8. å•ç‹¬æ›´æ–°é€‰ä¸­çŠ¶æ€ï¼ˆé¿å…å…¨é‡æ¸²æŸ“ï¼Œå…³é”®ä¼˜åŒ–ï¼‰
        function updateSelectedCells() {
            gridCells.forEach(cellEl => {
                const row = parseInt(cellEl.dataset.row);
                const col = parseInt(cellEl.dataset.col);
                const isSelected = path.some(p => p.row === row && p.col === col);
                if (isSelected) cellEl.classList.add('selected');
                else cellEl.classList.remove('selected');
            });
        }

        // 9. è¿çº¿ç»“ç®—ï¼ˆç®€åŒ–æµç¨‹+å‡å°‘å»¶è¿Ÿï¼‰
        function handleConnect() {
            // è®¡ç®—å¾—åˆ†ï¼ˆç®€åŒ–é€»è¾‘ï¼‰
            const connectNum = path.length;
            const addScore = connectNum >= 6 ? config.scoreRules['6+'] : config.scoreRules[connectNum];
            currentScore += addScore;
            connectCount += 1;

            // æ¶ˆé™¤æ ¼å­ï¼ˆç®€åŒ–å¾ªç¯ï¼‰
            path.forEach(({ row, col }) => gameGrid[row][col] = null);

            // ç«‹å³æ›´æ–°ä¿¡æ¯ï¼ˆæ— å»¶è¿Ÿï¼‰
            updateInfo();
            updateSelectedCells();

            // åŠ é€Ÿè¡¥ä½ï¼ˆå»¶è¿Ÿä»300msâ†’100msï¼Œå…³é”®ä¼˜åŒ–ï¼‰
            setTimeout(() => {
                const animateCells = fillEmptyCells();
                renderGrid(animateCells);
                ensurePlayableGrid();

                // æ¸¸æˆç»“æŸåˆ¤æ–­ï¼ˆç®€åŒ–ï¼‰
                if (connectCount >= config.maxConnect) {
                    setTimeout(endGame, 200); // å»¶è¿Ÿä»800msâ†’200ms
                }
            }, 100);

            // é‡ç½®çŠ¶æ€
            path = [];
            startPos = null;
        }

        // 10. è¡¥ä½é€»è¾‘ï¼ˆç®€åŒ–è®¡ç®—ï¼Œå…³é”®ä¼˜åŒ–ï¼‰
        function fillEmptyCells() {
            const animateCells = [];
            // æ¯åˆ—è¡¥ä½ï¼ˆç®€åŒ–å¾ªç¯ï¼‰
            for (let col = 0; col < config.gridSize; col++) {
                const column = [];
                // æ”¶é›†éç©ºæ ¼å­
                for (let row = 0; row < config.gridSize; row++) {
                    if (gameGrid[row][col]) column.push(gameGrid[row][col]);
                }
                // å¡«å……ç©ºç¼º
                const emptyCount = config.gridSize - column.length;
                for (let row = 0; row < config.gridSize; row++) {
                    if (row < emptyCount) {
                        gameGrid[row][col] = config.types[Math.floor(Math.random() * config.types.length)];
                        animateCells.push({ row, col, type: 'pop' });
                    } else {
                        gameGrid[row][col] = column[row - emptyCount];
                        animateCells.push({ row, col, type: 'fall' });
                    }
                }
            }
            return animateCells;
        }

        // 11. æ¸¸æˆç»“æŸï¼ˆç®€åŒ–å¼¹çª—é€»è¾‘ï¼‰
        function endGame() {
            const rankInfo = config.rankRules.find(r => currentScore >= r.min);
            let alertMsg = `å¾—åˆ†ï¼š${currentScore} | è¯„çº§ï¼š${rankInfo.rank}\n`;
            
            if (isOfficialGame) {
                alertMsg += `ç§¯åˆ†ï¼š${rankInfo.reward}åˆ†\nå‰©ä½™æ­£å¼å±€ï¼š${remainingOfficialCount}æ¬¡`;
            } else {
                alertMsg += `ï¼ˆè¯•ç©æ¨¡å¼ï¼‰`;
            }

            alert(alertMsg);
            initGrid(false);
        }

        // 12. æ›´æ–°ä¿¡æ¯ï¼ˆç®€åŒ–DOMæ“ä½œï¼‰
        function updateInfo() {
            scoreEl.textContent = currentScore;
            remainConnectEl.textContent = config.maxConnect - connectCount;
        }

        // 13. é‡æ–°å¼€å§‹æŒ‰é’®ï¼ˆç®€åŒ–é€»è¾‘ï¼‰
        restartBtn.addEventListener('click', () => {
            let isOfficial = false;
            if (remainingOfficialCount > 0) {
                isOfficial = confirm(`å‰©ä½™${remainingOfficialCount}æ¬¡æ­£å¼å±€ï¼Œæ˜¯å¦å¼€å¯ï¼Ÿ`);
            }
            initGrid(isOfficial);
        });

        // 14. é¡µé¢åŠ è½½ï¼ˆç®€åŒ–æœ¬åœ°å­˜å‚¨é€»è¾‘ï¼‰
        window.addEventListener('load', () => {
            const today = new Date().toDateString();
            const savedDate = localStorage.getItem('oceanMatchDate');
            
            if (savedDate !== today) {
                remainingOfficialCount = config.dailyOfficialCount;
                localStorage.setItem('oceanMatchDate', today);
                localStorage.setItem('oceanMatchOfficialCount', remainingOfficialCount);
            } else {
                const savedCount = localStorage.getItem('oceanMatchOfficialCount');
                if (savedCount) remainingOfficialCount = parseInt(savedCount);
            }

            officialCountEl.textContent = remainingOfficialCount;
            initGrid(false);
        });

        // ç¦ç”¨æ–‡å­—é€‰ä¸­ï¼ˆç®€åŒ–ï¼‰
        document.addEventListener('selectstart', e => e.preventDefault());
    </script>
</body>
</html>